---
title: C++_TIPS
categories: C++
tags:   -code
        -C++
---

## 基础
- [x] 目标程序/可执行程序
- [x] 预编译#include#define ""时先找用户目录再找系统的标准库目录
- [x] 变量赋初值 =...; (...);
- [x] C++规定各类整型的最少内存字节数，各类浮点数的最小精度6/10
- [x] 内置初始化：内置/函外=0;函内随机
- [ ] cin读到非空白不同变量停止 如12a34:只有12
- [ ] a=cin.get();/cin.get(a);
- [ ] 字符转成整型时，有的编译器0~255，有的-128~127
- [ ] 整型转字符，直接取最低8位
- [ ] 强制转换括号哪都行
- [ ] 逻辑表达式：短路求值
- [ ] case break default 可以多项
- [ ] for 逗号表达式 表达式2为逗号时关系为and
- [ ] 范围for (int i:{,})
- [ ] 
* 枚举类型
  enum 枚举类型名{元素表=0,1...};
  不可用整数赋值，输出为编码值
  可强制转换 ==
- [ ] 
* 类型别名
  typedef 原名 别名;
- [ ] 
* 类型空间量
  sizeof(类型名/表达式);
- [ ] 
* 整型
  长整型...L/l
  八进制 0...
  十六进制 0x...
- [ ] 
* 实型
  ...e/E...(整数)
  单精度...f/F
* 字符
  可用编码赋值
  转义字符/+八进制ASCII
* 符号常量
  宏#define
* 强制转换
  static_cast//无警告信息
  reinterpret_cast
  const_cast
  dynamic_cast
> 转换类型<类型名>(表达式)
* cmath
  fabs exp log10 asin
* 除法&取模
  向0取整
  负被除数的余为负
* 条件表达式
  (条件)? 式1:式2
* 随机
  <cstdlib>
  RAND_MAX
  rand() int [0,RAND_MAX]
  srand(time(NULL)) <ctime>
## 数组
- [x] 元素个数不能是变量
- [ ] {}赋初值，没赋到为0
- [ ] 配置长度/有效长度
- [ ] 范围for int/auto x:a
## 字符串
* cstring
  str/strn cmp cpy cat
  len
  strchr strrchr strstr

- [ ] cin/cout 以空白/\0截止
- [ ] cin.getline(数组,长度(包括\0),结束标记(不包括));
## 函数
* 函数模板
> template <class/typename T>
> T func(T a, T b){}

实例化
显式指定模板实参
> func(类型名, ,,)(,);

- [ ] 值传递计算顺序由编译器决定
- [ ] 一个帧 栈
- [ ] 静态变量，仅限该源文件，局部变量不重新创建，初始为0，不消亡但外部不能用 函数也可
- [ ] 寄存器变量(局部自动变量)表达意向，编译器自动决定
- [ ] 二维数组作为参数传递时，第二维不可省略
- [ ] 在声明处指定默认值
- [ ] 内联inline 必须定义在被调用前 取代宏 只是建议
- [ ] 重载 绑定
## 指针
- [ ] 统配指针类型 void *p;表示存放地址
- [ ] const int * const p=&x;
- [ ] 动态变量：堆 =new 类型名(初值) 失败赋空指针
- [ ] delete [ ] 指针变量 字符数组可不加[]
- [ ] assert (条件); <cassert>
- [ ] 变量和常量引用可以通过变量更改，常量不可
- [ ] 引用+范围for
- [ ] main参数 int argc char* agrv[]
- [ ] 命令名(可执行文件名)本身也是参数
- [ ] 多级指针 ********
- [ ] 函数指针 类型 (*指针变量)(); 数组()()={,} 赋值：指针名=函数名
- [ ] delete不存在的动态变量会使程序异常终止
## 结构体
- [ ] 可以直接在定义后定义变量 {} 变量名; (之后不再使用无需结构体名)
- [ ] 左值
## 类和对象
- [ ] 编译预处理：#ifndef 标识符 #define 标识符 ... #endif
- [ ] 默认构造函数 随机初始值 自己设了就没了
- [ ] =xxx是构造吗
- [ ] 舒适化列表 :a(x),b(y) 无; 提高效率 常量/类的对象
- [ ] 构造函数一开始会调用所有成员的构造函数
- [ ] 复制构造函数 const 类名 &名 值传递的话会死循环！
- [ ] 同上 定义 () = 传参数 返回值（自动创建）时调用
- [ ] 析构顺序 静态局部 全局
- [ ] 常量数据成员：必须初始化列表
- [ ] 常量对象只能用常量成员函数（定义和声明时都要加const）
- [ ] 静态数据成员不在对象定义时分配空间 实现文件 类型 类::变量名=;
- [ ] 静态成员函数无this 不能访问一般的数据成员 :修改静态成员 在实现文件中定义无需static
- [ ] 静态常量数据成员 必须在类定义时初始化 /enum {...=...
}
- [ ] 枚举类型可用于常量
- [ ] 友元函数 friend 声明
- [ ] 继承默认private
- [ ] 析构与构造次序相反
- [ ] 重定义基类函数默认使用最新定义的
- [ ] 不能把基类（指针）给派生类 哪怕基类指针指向派生类(强制类型转换)
- [ ] 派生类虚函数重定义时virtual 写不写都行
- [ ] 构造函数不能是虚函数 析构可以
- [ ] 纯虚函数=0 ——抽象类 不能定义对象 可以指针
## 类模板
- [ ] template<class T>...
- [ ] template<class T>
  返回类型 类名<T>::函数名(const 类名<t> 变量名)
  类名<类型名> 变量名; 定义 独立
  catch(...)
  https://www.cnblogs.com/pluse/p/9294419.html
  